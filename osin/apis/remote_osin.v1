from __future__ import annotations
import atexit
import shutil
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Set, Union
from gena.deserializer import get_deserializer_from_type

import orjson
from loguru import logger
from osin.apis.osin import Osin
from osin.apis.remote_exp import RemoteExp, RemoteExpRun
import requests
from osin.misc import get_caller_python_script, orjson_dumps
from osin.models.base import init_db
from osin.models.exp import Exp, ExpRun, NestedPrimitiveOutput, RunMetadata
from osin.models.exp_data import ExampleData, Record
from osin.params_helper import DataClassInstance, param_as_dict
from osin.repository import OsinRepository
from osin.types import NestedPrimitiveOutputSchema, ParamSchema, PyObject
from osin.types.primitive_type import validate_primitive_data
from dataclasses import asdict


ParamSchema_deser = get_deserializer_from_type(ParamSchema, {})
NestedPrimitiveOutputSchema_deser = get_deserializer_from_type(
    NestedPrimitiveOutputSchema, {}
)


class RemoteOsin(Osin):
    def __init__(self, endpoint: str, tmpdir: Path | str):
        super().__init__(tmpdir)
        self.endpoint = endpoint
        if self.endpoint.endswith("/"):
            self.endpoint = self.endpoint[:-1]
        self.tmpdir = Path(tmpdir)

    def init_exp(
        self,
        name: str,
        version: int,
        description: Optional[str] = None,
        program: Optional[str] = None,
        params: Optional[Union[DataClassInstance, List[DataClassInstance]]] = None,
        aggregated_primitive_outputs: Optional[NestedPrimitiveOutputSchema] = None,
        update_param_schema: bool = False,
    ) -> RemoteExp:
        exps = self._get(
            "/api/exp",
            {
                "name": name,
                "sorted_by": "-version",
                "limit": 1,
            },
        )["items"]
        if len(exps) == 0:
            if description is None or params is None:
                raise ValueError(
                    "Cannot create a new experiment without description and params"
                )

            exp = self._post(
                "/api/exp",
                {
                    "name": name,
                    "version": version,
                    "description": description,
                    "program": program or get_caller_python_script(),
                    "params": [
                        asdict(ParamSchema.get_schema(p))
                        for p in (params if isinstance(params, list) else [params])
                    ],
                    "aggregated_primitive_outputs": asdict(aggregated_primitive_outputs)
                    if aggregated_primitive_outputs is not None
                    else None,
                },
            )
        else:
            if exps[0]["version"] > version:
                raise ValueError("Cannot create an older version of an experiment")
            elif exps[0]["version"] == version:
                exp = exps[0]
                if update_param_schema:
                    self._put(
                        f"/api/exp/{exp['id']}",
                        {
                            "params": [
                                asdict(ParamSchema.get_schema(p))
                                for p in (
                                    params if isinstance(params, list) else [params]
                                )
                            ],
                        },
                    )
            else:
                if description is None or params is None:
                    raise ValueError(
                        "Cannot create a new experiment without description and params"
                    )
                exp = self._post(
                    "/api/exp",
                    {
                        "name": name,
                        "version": version,
                        "description": description,
                        "program": program or get_caller_python_script(),
                        "params": [
                            asdict(ParamSchema.get_schema(p))
                            for p in (params if isinstance(params, list) else [params])
                        ],
                        "aggregated_primitive_outputs": asdict(
                            aggregated_primitive_outputs
                        )
                        if aggregated_primitive_outputs is not None
                        else None,
                    },
                )

        return RemoteExp(
            id=exp["id"],
            name=exp["name"],
            version=exp["version"],
            params=[ParamSchema_deser(p) for p in exp["params"]],
            aggregated_primitive_outputs=NestedPrimitiveOutputSchema(
                exp["aggregated_primitive_outputs"]
            )
            if exp["aggregated_primitive_outputs"] is not None
            else None,
            osin=self,
        )

    def new_exp_run(
        self, exp: RemoteExp, params: Union[DataClassInstance, List[DataClassInstance]]
    ) -> RemoteExpRun:
        output = {}
        for param in params if isinstance(params, list) else [params]:
            output.update(param_as_dict(param))

        obj = self._post("/api/exprun", {"exp_id": exp.id, "params": output})
        exp_run = RemoteExpRun(
            id=obj["id"],
            exp=exp,
            created_time=obj["created_time"],
            finished_time=obj["finished_time"],
            rundir=self.tmpdir,
            osin=self,
        )

        rundir = self.osin_keeper.get_exp_run_dir(exp, exp_run)
        if rundir.exists():
            shutil.rmtree(rundir)
        rundir.mkdir(parents=True)
        exp_run.rundir = rundir

        atexit.register(
            self._cleanup,
            exp_run=exp_run,
        )
        return exp_run

    def finish_exp_run(self, exp_run: RemoteExpRun, is_successful: bool = True):
        """Flush whatever remaining in experiment run that haven't sent to the database to the database before stopping the experiment run."""
        exp_run.finished_time = datetime.utcnow()

        self.osin_keeper.get_exp_run_data_format(exp_run.exp, exp_run).save_run_data(
            exp_run.pending_output,
            self.osin_keeper.get_exp_run_data_file(exp_run.exp, exp_run),
        )

        metadata = RunMetadata.auto()
        # save metadata
        self.osin_keeper.get_exp_run_metadata_file(exp_run.exp, exp_run).write_bytes(
            orjson_dumps(
                {
                    "created_time": exp_run.created_time.isoformat(),
                    "finished_time": exp_run.finished_time.isoformat(),
                    "duration": (
                        exp_run.finished_time - exp_run.created_time
                    ).total_seconds(),
                    **metadata.to_dict(),
                },
                option=orjson.OPT_INDENT_2,
            )
        )

        # check if agg_lit_outputs matches with the schema.
        if exp_run.exp.aggregated_primitive_outputs is None:
            exp_run.exp.aggregated_primitive_outputs = (
                NestedPrimitiveOutputSchema.infer_from_data(
                    exp_run.pending_output.aggregated.primitive
                )
            )
            has_invalid_agg_output_schema = False
            Exp.update(
                aggregated_primitive_outputs=exp_run.exp.aggregated_primitive_outputs
            ).where(
                Exp.id == exp_run.exp.id
            ).execute()  # type: ignore
        else:
            has_invalid_agg_output_schema = (
                not exp_run.exp.aggregated_primitive_outputs.does_data_match(
                    exp_run.pending_output.aggregated.primitive
                )
            )

        self.osin_keeper.get_exp_run_success_file(exp_run.exp, exp_run).touch()
        ExpRun.update(
            is_finished=True,
            is_successful=is_successful,
            finished_time=exp_run.finished_time,
            has_invalid_agg_output_schema=has_invalid_agg_output_schema,
            metadata=metadata,
            aggregated_primitive_outputs=exp_run.pending_output.aggregated.primitive,
        ).where(
            ExpRun.id == exp_run.id
        ).execute()  # type: ignore

        self.cleanup_records.add(exp_run.id)

    def update_exp_run_output(
        self,
        exp_run: RemoteExpRun,
        primitive: Optional[NestedPrimitiveOutput] = None,
        complex: Optional[Dict[str, PyObject]] = None,
    ):
        assert False

    def update_example_output(
        self,
        exp_run: RemoteExpRun,
        example_id: str,
        example_name: str = "",
        primitive: Optional[NestedPrimitiveOutput] = None,
        complex: Optional[Dict[str, PyObject]] = None,
    ):
        assert False

    def _get(self, url: str, params: dict) -> dict:
        resp = requests.get(f"{self.endpoint}{url}", params=params, verify=False)
        try:
            assert resp.status_code == 200
        except:
            logger.error(resp.text)
            raise
        return resp.json()

    def _post(self, url: str, data: dict) -> dict:
        resp = requests.post(f"{self.endpoint}{url}", json=data, verify=False)
        try:
            assert resp.status_code == 200
        except:
            logger.error(resp.text)
            raise
        return resp.json()

    def _put(self, url: str, data: dict) -> dict:
        resp = requests.put(f"{self.endpoint}{url}", json=data, verify=False)
        try:
            assert resp.status_code == 200
        except:
            logger.error(resp.text)
            raise
        return resp.json()

    def _cleanup(self, exp_run: RemoteExpRun):
        if exp_run.id not in self.cleanup_records:
            logger.debug("Cleaning up exp run: {}", exp_run.id)
            if exp_run.finished_time is None:
                # the user may forget to call finish_exp_run
                # we decide that it is still a failure
                try:
                    self.finish_exp_run(exp_run, is_successful=False)
                except:
                    finished_time = datetime.utcnow()
                    ExpRun.update(
                        is_finished=True,
                        is_successful=False,
                        finished_time=finished_time,
                    ).where(
                        ExpRun.id == exp_run.id
                    ).execute()  # type: ignore

                    raise
            else:
                finished_time = datetime.utcnow()
                ExpRun.update(
                    is_finished=True, is_successful=False, finished_time=finished_time
                ).where(
                    ExpRun.id == exp_run.id
                ).execute()  # type: ignore

    def _find_latest_exp(self, name: str) -> Optional[Exp]:
        exps = self._get(
            "/api/exp",
            {
                "name": name,
                "sorted_by": "-version",
                "limit": 1,
            },
        )["items"]
        if len(exps) == 0:
            return None
        else:
            exp = exps[0]
            return Exp(
                id=exp["id"],
                name=exp["name"],
                version=exp["version"],
                description=exp["description"],
                program=exp["program"],
                params=[ParamSchema_deser(p) for p in exp["params"]],
                aggregated_primitive_outputs=NestedPrimitiveOutputSchema(
                    exp["aggregated_primitive_outputs"]
                )
                if exp["aggregated_primitive_outputs"] is not None
                else None,
            )

    def _create_exp(self, exp: Exp) -> Exp:
        if exp.description is None or exp.params is None:
            raise ValueError(
                "Cannot create a new experiment without description and params"
            )
        obj = self._post(
            "/api/exp",
            {
                "name": exp.name,
                "version": exp.version,
                "description": exp.description,
                "program": exp.program,
                "params": [asdict(p) for p in exp.params],
                "aggregated_primitive_outputs": asdict(exp.aggregated_primitive_outputs)
                if exp.aggregated_primitive_outputs is not None
                else None,
            },
        )
        exp.id = obj["id"]
        return exp

    def _update_exp(self, exp_id: int, exp: Exp, fields: List[str]):
        pass

    def _create_exprun(self, exprun: ExpRun) -> ExpRun:
        pass

    @abstractmethod
    def _update_exprun(self, exprun_id: int, exprun: ExpRun, fields: List[str]):
        pass
