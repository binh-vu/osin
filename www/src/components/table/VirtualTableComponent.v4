import { ClassNameMap, makeStyles } from "@mui/styles";
import { Skeleton, Table, theme, Typography } from "antd";
import {
  ColumnsType,
  ColumnType,
  ExpandableConfig,
  FilterValue,
  SorterResult,
  TablePaginationConfig,
} from "antd/lib/table/interface";
import { QueryConditions } from "gena-app";
import { getClassName } from "misc";
import { observer } from "mobx-react";
import React, {
  ForwardedRef,
  forwardRef,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from "react";
import { unstable_batchedUpdates } from "react-dom";
import {
  ColumnConfig,
  FlattenTableColumn,
  getRecordValue,
  TableColumn,
  TableColumnIndex,
  TableColumnMeasurement,
} from "./Columns";
import { TableToolbar } from "./TableToolBar";
import ResizeObserver from "rc-resize-observer";
import { VariableSizeGrid as Grid, FixedSizeList as List } from "react-window";
import InfiniteLoader from "react-window-infinite-loader";
import { TableComponentProps } from "./TableComponent";
import { useDeepCompareMemo } from "use-deep-compare";

const CSS_VIRTUAL_TABLE = "virtual-table";
const CSS_VIRTUAL_TABLE_SMALL = "virtual-table-small";
const CSS_VIRTUAL_TABLE_MEDIUM = "virtual-table-medium";
const CSS_VIRTUAL_TABLE_LARGE = "virtual-table-large";
const CSS_VIRTUAL_TABLE_BORDERED = "virtual-table-bordered";
const CSS_VIRTUAL_TABLE_CELL = "virtual-table-cell";

const VTSIZE = {
  small: CSS_VIRTUAL_TABLE_SMALL,
  middle: CSS_VIRTUAL_TABLE_MEDIUM,
  large: CSS_VIRTUAL_TABLE_LARGE,
};

const useStyles = makeStyles({
  root: {
    "& .virtual-table-small .virtual-table-cell": {
      padding: 8,
    },
    "& .virtual-table .virtual-table-cell": {
      display: "inline-block",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      overflow: "hidden",
    },
    "& .virtual-table-bordered .virtual-table-cell": {
      borderBottom: "1px solid rgba(5, 5, 5, 0.06)",
      borderRight: "1px solid rgba(5, 5, 5, 0.06)",
    },
    "& .virtual-table-bordered .virtual-table-cell:first-child": {
      borderLeft: "1px solid rgba(5, 5, 5, 0.06)",
    },
  },
});

export interface VirtualTablePaginationConfig {
  total: number;
  offset: number;
}

let tableMeasurement: TableColumnMeasurement | undefined = undefined;

export const VirtualTableComponent2 = <R extends object>(
  props: Pick<TableComponentProps<R>, "scroll" | "columns"> & {
    rowKey: keyof R;
    className?: string;
    size?: "small" | "middle" | "large";
    data: R[];
    bordered?: boolean;
    pagination: VirtualTablePaginationConfig;
    fetchData: any;
    internalColumns: TableColumnIndex<R>;
    setInternalColumns: (columns: TableColumnIndex<R>) => void;
  }
) => {
  const classes = useStyles();
  const { scroll } = props;
  const size = props.size || "small";
  // we have two numbers, the one is the width of the table container, and the other one is the total width of table columns
  const [containerWidth, setContainerWidth] = useState(1028);

  const [columns, leafColumns, totalColumnWidth] = useAutoTableWidth({
    internalColumns: props.internalColumns,
    columns: props.columns,
    data: props.data,
    containerWidth,
    headerExtraWidth: 16 + 16,
    cellExtraWidth: 16,
  });
  const height = scroll!.y as number;

  const gridRef = useRef<any>();
  const [connectObject] = useState<any>(() => {
    const obj = {};
    Object.defineProperty(obj, "scrollLeft", {
      get: () => {
        if (gridRef.current) {
          return gridRef.current.scrollLeft;
        }
        return null;
      },
      set: (scrollLeft: number) => {
        if (gridRef.current) {
          gridRef.current.scrollTo({ left: scrollLeft });
        }
      },
    });

    return obj;
  });

  const itemCount = props.pagination.total;
  const itemOffset = props.pagination.offset;
  const loadMoreItems = (start: number, end: number) => {
    console.log("loadMoreItems", { start, end, diff: end - start });
    return props.fetchData(start, end);
  };
  const getItem = (index: number) => {
    return props.data[index - itemOffset];
  };
  const isItemLoaded = (index: number) =>
    index - itemOffset < props.data.length;

  const renderBody = (
    rawData: readonly R[],
    { scrollbarSize, ref, onScroll }: any
  ) => {
    ref.current = connectObject;
    return (
      <div
        ref={gridRef}
        style={{ width: "100%", overflow: "auto" }}
        onScroll={() => {
          if (gridRef.current) {
            onScroll({ scrollLeft: gridRef.current.scrollLeft });
          }
        }}
      >
        <InfiniteLoader
          isItemLoaded={isItemLoaded}
          itemCount={itemCount}
          loadMoreItems={loadMoreItems}
          threshold={5}
        >
          {({ onItemsRendered, ref }: any) => {
            return (
              <List
                ref={ref}
                onItemsRendered={onItemsRendered}
                height={height}
                width={totalColumnWidth}
                itemSize={39.5}
                itemCount={itemCount}
                className={getClassName(CSS_VIRTUAL_TABLE, VTSIZE[props.size], [
                  props.bordered === true,
                  CSS_VIRTUAL_TABLE_BORDERED,
                ])}
              >
                {({ index, style }) => {
                  if (!isItemLoaded(index)) {
                    return (
                      <div key={index} style={style}>
                        Loading {index}...
                      </div>
                    );
                  }
                  return (
                    <VirtualRow
                      columns={leafColumns}
                      rowKey={props.rowKey}
                      record={getItem(index)}
                      style={style}
                    />
                  );
                }}
              </List>
            );
          }}
        </InfiniteLoader>
      </div>
    );
  };

  return (
    <div className={classes.root}>
      <ResizeObserver
        onResize={({ width }) => {
          setContainerWidth(width);
        }}
      >
        <Table
          className={getClassName(CSS_VIRTUAL_TABLE, props.className)}
          size={props.size}
          bordered={true}
          scroll={props.scroll}
          // dataSource={props.data}
          columns={columns}
          components={{
            body: renderBody,
          }}
          pagination={false}
        />
      </ResizeObserver>
    </div>
  );
};

const VirtualRow = <R extends object>(props: {
  rowKey: keyof R;
  record: R;
  columns: FlattenTableColumn<R>[];
  className?: string;
  style?: React.CSSProperties;
}) => {
  const cells = [];
  // for (const col of props.columns) {
  for (let i = 0; i < props.columns.length; i++) {
    const col = props.columns[i];
    let cell = getRecordValue(props.record, col);
    if (col.render !== undefined) {
      cell = col.render(cell, props.record, i);
    }
    cells.push(
      <div
        className={CSS_VIRTUAL_TABLE_CELL}
        style={{ width: col.moreWidth.user || col.moreWidth.auto }}
      >
        {cell}
      </div>
    );
  }
  return (
    <div
      key={props.record[props.rowKey] as React.Key}
      className={props.className}
      style={props.style}
    >
      {cells}
    </div>
  );
};

function renderCell2<R extends object>(
  record: any,
  column: TableColumn<R>,
  className: string,
  style: React.CSSProperties,
  left: number = 0
): React.ReactElement {
  let elem = null;
  let updatedStyle: any = { width: column.width as number };
  if (column.children === undefined) {
    elem = getRecordValue(record, column);
    if (column.render !== undefined) {
      elem = column.render(elem, record, 0);
    }
  } else {
    elem = [];
    for (let child of column.children) {
      const e = renderCell(record, child, className, style, left);
      elem.push(e);
      left += child.width as number;
    }
    return <React.Fragment key={column.key}>{elem}</React.Fragment>;
  }

  return (
    <div
      key={column.key}
      className={className}
      style={{ ...style, ...updatedStyle, left: left }}
      // style={{ width: column.width as number }}
    >
      {elem}
    </div>
  );
}

function renderCell<R extends object>(
  record: any,
  column: TableColumn<R>,
  className: string,
  style: React.CSSProperties,
  left: number = 0
): React.ReactElement {
  let elem = null;
  let updatedStyle: any = { width: column.width as number };
  if (column.children === undefined) {
    elem = getRecordValue(record, column);
    if (column.render !== undefined) {
      elem = column.render(elem, record, 0);
    }
  } else {
    elem = [];
    for (let child of column.children) {
      const e = renderCell(record, child, className, style, left);
      elem.push(e);
      left += child.width as number;
    }
    return <React.Fragment key={column.key}>{elem}</React.Fragment>;
  }

  return (
    <div
      key={column.key}
      className={className}
      style={{ ...style, ...updatedStyle, left: left }}
      // style={{ width: column.width as number }}
    >
      {elem}
    </div>
  );
}

/**
 * Re-calculate the table width when:
 *
 * (1) the columns change
 * (2) the container width changes
 * (3) the data changes (but only for the first time!)
 */
function useAutoTableWidth<R extends object>({
  containerWidth,
  data,
  columns,
  internalColumns,
  headerExtraWidth = 16,
  cellExtraWidth = 16,
}: {
  containerWidth: number;
  data: R[];
  columns: TableColumn<R>[];
  internalColumns: TableColumnIndex<R>;
  headerExtraWidth?: number;
  cellExtraWidth?: number;
}): [TableColumn<R>[], FlattenTableColumn<R>[], number] {
  const previousDataRef = useRef<R[]>();
  const matterColumns = internalColumns.getLeafColumns().map((col) => ({
    key: col.key,
    title: col.title,
    width: col.width,
    moreWidth: col.moreWidth,
  }));

  return useDeepCompareMemo(() => {
    // const vvv = (previousDataRef.current || []).length > 0;
    // set the data if it's the first time or we haven't received any meaningful data yet
    if ((previousDataRef.current || []).length === 0) {
      previousDataRef.current = data;
    }
    // compute the width of leaf columns
    const c2w = computeColumnWidths(internalColumns, previousDataRef.current!, {
      tableWidth: containerWidth,
      headerExtraWidth,
      cellExtraWidth,
    });
    const totalWidth = Array.from(c2w.values()).reduce((a, b) => a + b, 0);

    // console.log("deep compare", containerWidth, vvv, matterColumns, c2w);
    const newInternalColumns = internalColumns.setColumnAutoWidth(
      (col) => c2w.get(col.key)!
    );
    return [
      newInternalColumns.getAntdColumns(true),
      newInternalColumns.getLeafColumns(),
      totalWidth,
    ];
  }, [
    containerWidth,
    (previousDataRef.current || []).length > 0,
    matterColumns,
  ]);
}

/**
 * This function calculates width of each column such that:
 *
 * (1) the total column width is greater than or equal to the table width
 * (2) the amount of column width is allocated based on its relative length with other columns
 * (3) the minimum width of each column is determined based on its header text. We don't want
 *     the header text to be truncated.
 *
 * First, we remove the columns that already had a width specified by the user, and update the table width.
 * Then, if the total minimum width is greater than the table width, we use the minimum width. Otherwise,
 * each column will get an extra width from the remaining space based on its ratio (with some special handling for extra spaces).
 */
function computeColumnWidths<R extends object>(
  internalColumns: TableColumnIndex<R>,
  data: R[],
  options: {
    tableWidth: number;
    headerExtraWidth: number;
    cellExtraWidth: number;
    knownColumnWidths?: Map<React.Key, number>;
  }
): Map<React.Key, number> {
  if (tableMeasurement === undefined) {
    // default font in antd table
    const fontFamily =
      '-apple-system, "system-ui", "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"';
    tableMeasurement = new TableColumnMeasurement(
      `normal normal 600 14px ${fontFamily}`,
      `normal normal 400 14px ${fontFamily}`
    );
  }

  // calculate column widths of unfixed columns
  let isAccurate = true;
  let tableWidth = options.tableWidth;
  const leafColumns = internalColumns.getLeafColumns();
  const columns: FlattenTableColumn<R>[] = [];
  const unfixedIndices: Map<number, number> = new Map();
  const headers = [];
  const cells = [];
  for (let i = 0; i < leafColumns.length; i++) {
    const col = leafColumns[i];
    if (col.moreWidth.user === undefined) {
      unfixedIndices.set(i, columns.length);
      columns.push(col);
      // use default header Name in case title is a ReactNode, if users don't like it, they 'may' adjust the width manually themselves
      headers.push(typeof col.title === "string" ? col.title : "Name");
      cells.push(data.map((r) => getRecordValue(r, col)));

      if (typeof col.title !== "string" || col.render !== undefined) {
        // we can't accurately measure the width of the column because the header text is a ReactNode or the column has a custom render function
        // so that users can gather the width of the column themselves
        isAccurate = false;
      }
    } else {
      tableWidth -= col.moreWidth.user;
    }
  }
  const minimumWidths = headers.map(tableMeasurement!.measureHeaderTextWidth);
  const totalMinimumWidth =
    minimumWidths.reduce((a, b) => a + b, 0) +
    options.headerExtraWidth * headers.length;

  let columnWidths = tableMeasurement.measureColumnWidths(headers, cells);
  let extraWidths = columnWidths.map((w, i) =>
    w === minimumWidths[i] ? options.headerExtraWidth : options.cellExtraWidth
  );

  if (totalMinimumWidth <= tableWidth) {
    // we can fit all columns within the table width
    let remainSpace = tableWidth - totalMinimumWidth;
    const totalExtraWidth = extraWidths.reduce((a, b) => a + b, 0);
    const totalColumnWidth = columnWidths.reduce((a, b) => a + b, 0);
    const columnRatio = columnWidths.map((w) => w / totalColumnWidth);
    if (remainSpace > totalExtraWidth) {
      remainSpace -= totalExtraWidth;
    } else {
      // no space for extra width
      extraWidths = columnWidths.map(() => 0);
    }
    columnWidths = columnWidths.map((w, i) => {
      return columnWidths[i] + columnRatio[i] * remainSpace;
    });
  } // else, cannot fit all columns, so we just use the column widths + extraWidth as users have to scroll anyway

  return new Map(
    leafColumns.map((c, i) => {
      if (unfixedIndices.has(i)) {
        const j = unfixedIndices.get(i)!;
        return [c.key, columnWidths[j] + extraWidths[j]];
      }
      return [c.key, c.moreWidth.user!];
    })
  );
}
