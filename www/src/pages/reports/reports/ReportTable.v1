import { makeStyles } from "@mui/styles";
import { Dropdown } from "antd";
import axios from "axios";
import { SERVER } from "env";
import { InternalLink } from "gena-app";
import { getClassName } from "misc";
import { ExpIndex, Index, Report, ReportTableArgs } from "models/reports";
import { useEffect, useState } from "react";
import { routes } from "routes";

const useStyles = makeStyles({
  root: {},
  table: {
    marginLeft: "auto",
    marginRight: "auto",
    border: "1px solid #ddd",
    "& td,th": {
      border: "1px solid #ddd",
    },
  },
  smallTable: {
    "& td,th": {
      padding: 8,
    },
  },
  middleTable: {
    "& td,th": {
      padding: "12px 8px",
    },
  },
  largeTable: {
    "& td,th": {
      padding: 16,
    },
  },
  caption: {
    textAlign: "center",
    captionSide: "top",
  },
  footnote: {
    textAlign: "right",
    captionSide: "bottom",
    paddingTop: "0.3em",
  },
  actionSep: {
    fontWeight: 900,
    paddingLeft: 4,
    paddingRight: 4,
    color: "#1890ff",
  },
});

type IndexSchema =
  | string[]
  | { values: (string | number | boolean | null)[]; expId: number }[];
interface ReportTableData {
  data: {
    x: string[];
    y: string[];
    z: {
      name: string[];
      value: string | boolean | number;
      run_id: number;
    }[];
  }[];
  xitems: string[][];
  yitems: string[][];
  // schema at each index level
  xitems_schema: IndexSchema[];
  yitems_schema: IndexSchema[];
}
type HighlightMode = "none" | "row" | "col" | "cell";
const highlightModes: HighlightMode[] = ["none", "row", "col", "cell"];

export const ReportTable = ({
  expId,
  report,
}: {
  expId: number;
  report: Report;
}) => {
  const classes = useStyles();
  const tableargs = report.args as ReportTableArgs;
  const [data, setData] = useState<ReportTableData>({
    data: [],
    xitems: [],
    yitems: [],
    xitems_schema: [],
    yitems_schema: [],
  });
  const [highlight, setHighlight] = useState<HighlightMode>("none");

  useEffect(() => {
    axios.get(`${SERVER}/api/report/${report.id}/data`).then((res) => {
      const mapfn = (
        indexschema: string[] | [number, (string | number | boolean | null)[]]
      ) => {
        if (Array.isArray(indexschema)) {
          return indexschema;
        } else {
          return {
            expId: indexschema[0],
            values: indexschema[1],
          };
        }
      };
      res.data.xitems_schema = res.data.xitems_schema.map(mapfn);
      res.data.yitems_schema = res.data.yitems_schema.map(mapfn);

      setData(res.data);
    });
  }, []);

  const table = new ReportTableBuilder(data).build_v2(highlight);

  const actions = (
    <>
      <InternalLink
        path={routes.updatereport}
        urlArgs={{ expId, reportId: report.id }}
        queryArgs={{}}
      >
        edit the table
      </InternalLink>
      <span className={classes.actionSep}>&#183;</span>
      <Dropdown
        menu={{
          items: highlightModes.map((mode) => ({ label: mode, key: mode })),
          selectedKeys: [highlight],
          onClick: ({ key }) => setHighlight(key as HighlightMode),
        }}
      >
        <a>highlights</a>
      </Dropdown>
    </>
  );

  let footnote = undefined;
  if (tableargs.value.zvalues.length === 1) {
    let metric = undefined;
    if (tableargs.value.zvalues[0] instanceof Index) {
      metric = tableargs.value.zvalues[0].index.join(".");
    } else {
      const tmp = new Set(
        Object.values(tableargs.value.zvalues[0].indices).map((idx) => {
          return idx instanceof Index ? idx.index.join(".") : idx;
        })
      );
      if (tmp.size === 1) {
        metric = tmp.values().next().value;
      }
    }
    if (metric !== undefined) {
      footnote = (
        <caption className={classes.footnote}>
          *each cell shows the average of {metric} - {actions}
        </caption>
      );
    }
  }
  if (footnote === undefined) {
    footnote = <caption className={classes.footnote}>{actions}</caption>;
  }

  return (
    <div className={classes.root}>
      <table className={getClassName(classes.table, classes.largeTable)}>
        <caption className={classes.caption}>
          Table {report.id}. {report.name}: {report.description}.
        </caption>
        <tbody>
          {table.map((row, ri) => {
            return (
              <tr key={ri}>
                {row.map((cell, ci) => {
                  return <Cell key={`${ri}-${ci}`} cell={cell} />;
                })}
              </tr>
            );
          })}
        </tbody>
        {footnote}
      </table>
    </div>
  );
};

interface Cell {
  // whether the cell is a header
  th: boolean;
  value: string | React.ReactElement;
  className?: string;
  style?: React.CSSProperties;
  colspan: number;
  rowspan: number;
}

const Cell = ({ cell }: { cell: Cell }) => {
  if (cell.th) {
    return (
      <th style={cell.style} rowSpan={cell.rowspan} colSpan={cell.colspan}>
        {cell.value}
      </th>
    );
  }
  return (
    <td style={cell.style} rowSpan={cell.rowspan} colSpan={cell.colspan}>
      {cell.value}
    </td>
  );
};

const CellValue = ({
  values,
}: {
  values: (string | number | boolean | null)[];
}) => {
  if (values.length === 0) {
    return <></>;
  }

  if (values.every((v) => typeof v === "number")) {
    const mean =
      (values as number[]).reduce((a, b) => a + b, 0) / values.length;
    return <>{mean.toFixed(3)}</>;
  }

  return <>{values.join(", ")}</>;
};

class ReportTableBuilder {
  data: {
    x: string;
    y: string;
    z: {
      name: string;
      value: string | boolean | number;
      run_id: number;
    }[];
  }[];
  colIndices: string[][];
  rowIndices: string[][];
  colIndexSchema: IndexSchema[];
  rowIndexSchema: IndexSchema[];
  rowIndexMap: { [key: string]: number };
  colIndexMap: { [key: string]: number };

  constructor(data: ReportTableData) {
    this.data = [];
    this.colIndices = data.xitems;
    this.rowIndices = data.yitems;
    this.colIndexSchema = data.xitems_schema;
    this.rowIndexSchema = data.yitems_schema;

    this.rowIndexMap = Object.fromEntries(
      this.rowIndices.map((idx, i) => [idx.join("."), i])
    );
    this.colIndexMap = Object.fromEntries(
      this.colIndices.map((idx, i) => [idx.join("."), i])
    );
    for (const r of data.data) {
      this.data.push({
        x: r.x.join("."),
        y: r.y.join("."),
        z: r.z.map((rz) => ({
          name: rz.name.join("."),
          value: rz.value,
          run_id: rz.run_id,
        })),
      });
    }
  }

  /**
   * Build a table from the data
   */
  build_v1() {
    const { data, colIndices, rowIndices } = this;
    const nAddedRows = colIndices.length > 0 ? colIndices[0].length : 0;
    const nAddedColumns = rowIndices.length > 0 ? rowIndices[0].length : 0;

    const nrows = rowIndices.length + nAddedRows;
    const ncols = colIndices.length + nAddedColumns;

    const row = [];
    for (let i = 0; i < ncols; i++) {
      row.push("");
    }

    const table: any[][] = [];
    for (let i = 0; i < nrows; i++) {
      table.push(row.slice());
    }

    for (let i = nAddedRows; i < nrows; i++) {
      for (let j = 0; j < nAddedColumns; j++) {
        table[i][j] = { value: rowIndices[i - nAddedRows][j], th: true };
      }
    }
    for (let i = 0; i < nAddedRows; i++) {
      for (let j = nAddedColumns; j < ncols; j++) {
        table[i][j] = { value: colIndices[j - nAddedColumns][i], th: true };
      }
    }

    for (let i = nAddedRows; i < nrows; i++) {
      for (let j = nAddedColumns; j < ncols; j++) {
        table[i][j] = [];
      }
    }

    this.addData(table, nAddedRows, nAddedColumns);
    return table;
  }

  build_v2(highlight: HighlightMode) {
    const { colIndices, rowIndices } = this;
    const nAddedRows = colIndices.length > 0 ? colIndices[0].length : 0;
    const nAddedColumns = rowIndices.length > 0 ? rowIndices[0].length : 0;

    const rowstart = nAddedRows * 2;
    const colstart = nAddedColumns * 2;
    const nrows = rowIndices.length + rowstart;
    const ncols = colIndices.length + colstart;

    const table: Cell[][] = [];
    for (let i = 0; i < nrows; i++) {
      const row = [];
      for (let i = 0; i < ncols; i++) {
        row.push({ th: false, value: "", colspan: 1, rowspan: 1 });
      }
      table.push(row);
    }
    for (let i = 0; i < rowstart; i++) {
      for (let j = 0; j < colstart; j++) {
        table[i][j].style = {
          border: "none",
        };
      }
    }

    for (let i = rowstart; i < nrows; i++) {
      for (let j = 0; j < nAddedColumns; j++) {
        const rowindexmedata = this.rowIndexSchema[j];
        table[i][j * 2] = {
          ...table[i][j * 2],
          th: true,
          style: {
            borderRight: "none",
            transform: "rotate(-180deg)",
            writingMode: "vertical-lr",
            padding: 0,
          },
        };
        if (Array.isArray(rowindexmedata)) {
          table[i][j * 2].value = rowindexmedata.join(".");
          if (i === rowstart) {
            table[i][j * 2].rowspan = rowIndices.length;
          }
        } else {
          // how about the ExpIndex?
          throw new Error("not implemented");
        }
        table[i][j * 2 + 1] = {
          ...table[i][j * 2 + 1],
          th: true,
          value: rowIndices[i - rowstart][j],
          style: { borderLeft: "none" },
        };
      }
    }
    for (let i = 0; i < nAddedRows; i++) {
      for (let j = colstart; j < ncols; j++) {
        const colindexmetadata = this.colIndexSchema[i];
        table[i * 2][j] = {
          ...table[i * 2][j],
          th: true,
          style: { borderBottom: "none", padding: 0 },
        };

        if (Array.isArray(colindexmetadata)) {
          table[i * 2][j].value = colindexmetadata.join(".");
          if (j === colstart) {
            // we can set the colspan here so it doesn't repeat for each column
            table[i * 2][j].colspan = colIndices.length;
          }
        } else {
          // how about the ExpIndex?
          throw new Error("not implemented");
        }
        table[i * 2 + 1][j] = {
          ...table[i * 2 + 1][j],
          th: true,
          value: colIndices[j - colstart][i],
          style: {
            borderTop: "none",
          },
        };
      }
    }

    this.addData(table, rowstart, colstart);
    this.fixSpanning(table);
    return table;
  }

  /**
   * For html table spanning to work correctly, if the cell is column spanned, then the cell on the right
   * must be removed. If the cell is row spanned, then the cell below must be removed.
   *
   * This simple algorithm works by first creating a flag table, in which each cell is marked as false
   * if it is supposted to be removed. Then the table is traversed from top to bottom, left to right, and
   * remove the cell if it is marked as true.
   */
  fixSpanning(table: Cell[][]) {
    if (table.length === 0) {
      return;
    }
    const nrows = table.length;
    const ncols = table[0].length;
    const flags: boolean[][] = [];

    for (let i = 0; i < nrows; i++) {
      flags.push([]);
      for (let j = 0; j < ncols; j++) {
        flags[i].push(true);
      }
    }

    for (let i = 0; i < nrows; i++) {
      for (let j = 0; j < ncols; j++) {
        const cell = table[i][j];
        for (let k = 1; k < cell.colspan; k++) {
          flags[i][j + k] = false;
        }
        for (let k = 1; k < cell.rowspan; k++) {
          flags[i + k][j] = false;
        }
      }
    }

    for (let i = 0; i < nrows; i++) {
      table[i] = table[i].filter((_, j) => flags[i][j]);
    }
  }

  addData(table: Cell[][], rowstart: number, colstart: number) {
    if (table.length === 0) {
      return;
    }
    const nrows = table.length;
    const ncols = table[0].length;

    const cells = [];
    for (const record of this.data) {
      const { x: col, y: row, z: values } = record;
      const i = this.rowIndexMap[row] + rowstart;
      const j = this.colIndexMap[col] + colstart;
      if (new Set(values.map((value) => value.name)).size !== 1) {
        throw new Error("not implemented");
      }
      table[i][j].value = <CellValue values={values.map((v) => v.value)} />;
    }
  }
}
